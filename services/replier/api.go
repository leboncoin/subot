package replier

import (
	"encoding/json"
	"time"

	"github.com/swaggo/files"
	"github.com/swaggo/gin-swagger"

	_ "github.com/leboncoin/subot/services/analytics/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/gin-gonic/gin"
	log "github.com/sirupsen/logrus"
	"github.com/leboncoin/subot/pkg/globals"
	"github.com/leboncoin/subot/pkg/slack"
)

// @title Support Replier public API
// @version 1.0
// @description Replier service for the Subot project
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email clement.mondion@adevinta.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @schemes https
// @BasePath /v1
func runAPI(instance *Handler) {
	r := gin.Default()
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})

	// use ginSwagger middleware to serve the API docs
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Slack webhook endpoint
	r.GET("/catchup", func(c *gin.Context) {
		start := c.DefaultQuery("start", "2019-01-01")
		end := c.DefaultQuery("end", time.Now().Format(globals.DateLayout))
		go instance.CatchUp(start, end)
		c.JSON(200, gin.H{
			"status": "ok",
		})
	})

	// Slack webhook endpoint
	r.POST("/event", func(c *gin.Context) {
		var eventRequest slack.EventRequest
		log.WithFields(log.Fields{"event": eventRequest.Event, "type": eventRequest.Type}).Debug("Event received")
		if err := c.BindJSON(&eventRequest); err == nil {
			if eventRequest.Type == "url_verification" {
				log.Debug("Event is a challenge")
				c.JSON(200, gin.H{
					"challenge": eventRequest.Challenge,
				})
			} else {
				go instance.HandleNewEvent(eventRequest)
				c.JSON(200, gin.H{
					"status": "ok",
				})
			}
		} else {
			log.Debug(err)
			c.JSON(400, gin.H{
				"Error": err,
			})
		}
	})

	// Slack interactivity endpoint
	r.POST("/interactivity", func(c *gin.Context) {
		var interactivityRequest slack.InteractivityRequest
		log.Debug("Interactivity event received")
		payload := c.PostForm("payload")

		if err := json.Unmarshal([]byte(payload), &interactivityRequest); err == nil {
			go instance.HandleNewInteraction(interactivityRequest)
			c.JSON(200, gin.H{
				"status": "ok",
			})
		} else {
			log.Debug(err)
			c.JSON(400, gin.H{
				"Error": err,
			})
		}
	})

	// [POC] slack command endpoint to manage incidents
	r.POST("/commands/incident", func(c *gin.Context) {
		var commandRequest slack.CommandRequest
		if err := c.Bind(&commandRequest); err != nil {
			log.Error("error parsing command", err)
			c.JSON(400, gin.H{"error": err})
		} else {
			instance.HandleNewIncident(commandRequest)
			c.JSON(200, gin.H{
				"blocks": []map[string]interface{}{
					{
						"type": "section",
						"text": map[string]string{
							"type": "mrkdwn",
							"text": "*Je m'occupe de la gestion de crise*",
						},
					},
				},
			})
		}
	})

	// [POC] slack command endpoint to manage repositories
	r.POST("/commands/repo", func(c *gin.Context) {
		var commandRequest slack.CommandRequest
		if err := c.BindJSON(&commandRequest); err != nil {
			log.Error("error parsing command", err)
			c.JSON(400, gin.H{"error": err})
		} else {
			instance.HandleNewRepo(commandRequest)
			c.JSON(200, gin.H{
				"blocks": map[string]interface{}{
					"type": "section",
					"text": map[string]string{
						"type": "mrkdwn",
						"text": "*Repository created*",
					},
				},
			})
		}
	})

	r.GET("/report", func(c *gin.Context) {
		instance.SendWeeklyReport()
		c.JSON(200, gin.H{
			"report": "okay",
		})
	})

	r.GET("/remind", func(c *gin.Context) {
		instance.SendReminders()
		c.JSON(200, gin.H{
			"remind": "okay",
		})
	})

	err := r.Run() // listen and serve on 0.0.0.0:8080
	if err != nil {
		log.Fatalf("Could not serve server : %s", err)
	}
}
